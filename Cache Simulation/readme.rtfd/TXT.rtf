{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Garamond;\f1\fswiss\fcharset0 Helvetica;\f2\ftech\fcharset77 Symbol;
\f3\fmodern\fcharset0 CourierNewPSMT;\f4\froman\fcharset0 TimesNewRomanPSMT;\f5\fmodern\fcharset0 CourierNewPS-BoldMT;
\f6\fmodern\fcharset0 CourierNewPS-ItalicMT;\f7\froman\fcharset0 Times-Roman;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red11\green76\blue181;\red82\green0\blue83;
\red24\green41\blue81;\red12\green12\blue12;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;\cssrgb\c1961\c38824\c76078;\cssrgb\c40000\c0\c40000;
\cssrgb\c12157\c21961\c39216;\cssrgb\c5098\c5098\c5098;}
\paperw11900\paperh16840\margl1440\margr1440\vieww28600\viewh16280\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs24 \cf2 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720\partightenfactor0

\b \cf2 Basic Procedures\
\pard\pardeftab720\partightenfactor0

\b0\fs22 \cf2 You must:\
\pard\pardeftab720\partightenfactor0

\f1 \cf2 \uc0\u61589 
\f2  
\f0 Fill out a readme.txt file with your information (goes in your user folder, an example readme.txt file is\
provided)\

\f1 \uc0\u61589 
\f2  
\f0 Have a style (indentation, good variable names, etc.)\

\f1 \uc0\u61589 
\f2  
\f0 Comment your code well in JavaDoc style (no need to overdo it, just do it well)\

\f1 \uc0\u61589 
\f2  
\f0 Have code that compiles with the command: javac *.java in your user directory\
\pard\pardeftab720\partightenfactor0

\fs24 \cf2 You may:\
\pard\pardeftab720\partightenfactor0

\f1\fs22 \cf2 \uc0\u61589 
\f2  
\f0 Add additional methods, fields, and classes, however these must be private (or package default for\
fields/methods inside nested classes).\

\f1 \uc0\u61589 
\f2  
\f0\b Allowed classes to use as the starting point of your implementation (either import or include\
source code in your submission):\
\pard\pardeftab720\partightenfactor0

\f3\b0 \cf2 o 
\f0 Java class: util.HashMap, util.TreeSet\

\f3 o 
\f0 Any Weiss code from \cf3 http://users.cs.fiu.edu/~weiss/dsj4/code/code.html\

\f3 \cf2 o 
\f0 One additional Weiss class: \cf3 http://users.cs.fiu.edu/~weiss/dsaajava3/code/AvlTree.java\

\f3 \cf2 o 
\f0 Any class you implemented for a previous project of CS310 this semester\
\pard\pardeftab720\partightenfactor0

\fs24 \cf2 You may 
\b not
\b0 :\
\pard\pardeftab720\partightenfactor0

\f1\fs22 \cf2 \uc0\u61589 
\f2  
\f0 Make your program part of a package.\

\f1 \uc0\u61589 
\f2  
\f0 Add additional public methods, variables, or classes.\

\f1 \uc0\u61589 
\f2  
\f0 Import / use any built-in Java Library classes that are not included in the above allowed list (e.g. no\
ArrayList, LinkedList, Queue, etc.) or add any additional import statements.\

\f1 \uc0\u61589 
\f2  
\f0 Alter any method signatures defined in this document or the template code.\

\f1 \uc0\u61589 
\f2  
\f0 Add any additional libraries/packages which require downloading from the internet\
\pard\pardeftab720\partightenfactor0

\b\fs24 \cf2 Submission Instructions\
\pard\pardeftab720\partightenfactor0

\f1\b0\fs22 \cf2 \uc0\u61589 
\f2  
\f0 Make a backup copy of your user folder!\

\f1 \uc0\u61589 
\f2  
\f0 Remove all test files, jar files, class files, etc.\

\f1 \uc0\u61589 
\f2  
\f0\b In additional to your java files and your readme.txt, you will need to submit a design\
document 
\b0 as either a plain TEXT file (design.txt) or a PDF file (design.pdf) which include\
\pard\pardeftab720\partightenfactor0

\f3 \cf2 o 
\f0 Description of the underlying data structures for the three interfaces you need to implement\
for this project.\

\f3 o 
\f0 The source (reference) of any class that you used in your code that is not written by you.\
These must be from the list of allowed classes from above.\
\pard\pardeftab720\partightenfactor0

\f4\fs24 \cf2 2\
\pard\pardeftab720\partightenfactor0

\f3\fs22 \cf2 o 
\f0 For your implementation of 
\f5\b\fs20 \cf4 MySequence 
\f0\b0\fs22 \cf2 class, a description and algorithm sketch of\
method 
\f5\b\fs20 \cf4 countNoSmallerThan()\
\pard\pardeftab720\partightenfactor0

\f1\b0\fs22 \cf2 \uc0\u61589 
\f2  
\f0 Zip your user folder (not just the files) and name it as \'93
\f3 section-yourGMUUserNamep4.\
zip
\f0 \'94 (no other type of archive) where \'93
\f3 yourGMUUserName
\f0 \'94 is your GMU email address /\
netID.\

\f1 \uc0\u61589 
\f2  
\f0 Submit to blackboard.\
\pard\pardeftab720\partightenfactor0

\b\fs24 \cf2 Grading Rubric\
\pard\pardeftab720\partightenfactor0

\b0\fs22 \cf2 Due to the complexity of this assignment, an accompanying grading rubric pdf has been included with this\
assignment. Please refer to this document for a complete explanation of the grading.\
\pard\pardeftab720\partightenfactor0

\b\fs24 \cf2 Topics Covered\
\pard\pardeftab720\partightenfactor0

\b0\fs22 \cf2 Self-Balancing Binary Search Tree, Priority Queue, Hash Table\
\pard\pardeftab720\partightenfactor0

\b\fs28 \cf5 Overview\
\pard\pardeftab720\partightenfactor0

\b0\fs24 \cf2 In this project, your task is to simulate how cache works using the OPT replacement policy to\
replace the addresses stored. Cache is the component that stores data that is in demand and can be\
quickly accessed. However, unlike long-term storage spaces, cache consists of only a limited amount\
of space that consequently requires one of the addresses to be replaced with a newly accessed\
address that is not in the cache. If an address requested by a reference is already in cache, the\
reference is considered as a cache 
\b hit
\b0 ; otherwise, it is considered as cache 
\b miss
\b0 . A new address will\
need to be added into the cache when there is a cache miss. If there is still unused space in cache, it\
is straightforward to add. If the cache is already full, we will have to select one existing address from\
cache to 
\b replace
\b0 . Check \cf3 http://en.wikipedia.org/wiki/CPU_cache \cf2 for an overview of cache.\
There are a lot of cache replacement policies. You can find an overview of them here:\
\pard\pardeftab720\partightenfactor0
\cf3 http://en.wikipedia.org/wiki/Cache_replacement_policies\cf2 . The one that you need to implement is\
called 
\b OPT 
\b0 (Optimal Page Replacement) policy[1]. When a replacement is needed, this policy\
selects the address whose next use will occur farthest in the future as the victim to be swapped out.\
It outperforms other cache replacement policies but not implementable in practice because future\
information is needed to make the decision of replacement. Check and [1] and page 5 of this\
document for some examples.\
We will assume that the complete sequence of references is available and simulate a cache with OPT\
replacement policy in this project. The simulation is performed in two rounds of processing on the\
given sequence of accesses [1].\
\pard\pardeftab720\partightenfactor0

\f1 \cf2 \uc0\u61589 
\f2  
\f0 The first round is used to collect necessary information regarding future references so that\
we can always order the existing addresses in a cache based on who will not be needed for\
the longest time. This will be performed by scanning the given sequence of references in\
reverse order.\

\f1 \uc0\u61589 
\f2  
\f0 The second round will simulate the OPT cache, access the address sequence in order one by\
one, using the information collected in the first round to decide replacement candidate when\
needed, and accumulate the number of cache hits/misses.\
\
\pard\pardeftab720\partightenfactor0

\f4 \cf2 3\
\pard\pardeftab720\partightenfactor0

\f0 \cf2 Round 1\
For the first round, we scan the given sequence of references in reverse order, and collect an LRU\
stack distance defined as below for each access.\
\pard\pardeftab720\partightenfactor0

\b \cf2 Definition 1
\b0 : 
\b LRU Stack distance 
\b0 of a reference to 
\f5\b X 
\f0\b0 at time 
\f5\b T 
\f0\b0 is the number of distinct addresses\
referenced at time 
\f5\b T', T'+1, T'+2, . . ., T-1 
\f0\b0 where 
\f5\b T' 
\f0\b0 is the last time 
\f5\b X 
\f0\b0 is\
referenced. If 
\f5\b X 
\f0\b0 has never been referenced before, the stack distance is infinity.\
For example, using a letter to represent each address, we can represent a reference sequence and the\
corresponding LRU stack distance for each access as below:\
\pard\pardeftab720\partightenfactor0

\i \cf2 Access time: 
\f3\i0 0 1 2 3 4 5 6 7 8 9\

\f0\i (Reverse) Access sequence: 
\f3\i0 d c d a b d a c b a\

\f0\i LRU stack distance: 
\i0 \uc0\u8734  \u8734  2 \u8734  \u8734  3 3 4 4 3\
Explanation for some examples:\
\pard\pardeftab720\partightenfactor0

\f1 \cf2 \uc0\u61589 
\f2  
\f0 The access to address d at time 0 has an infinite stack distance since d has never been\
accessed before.\

\f1 \uc0\u61589 
\f2  
\f0 The access to address d at time 2 has a stack distance of 2 because two distinct addresses (c\
and d itself) have been accessed since last time d is accessed (at time 0).\

\f1 \uc0\u61589 
\f2  
\f0 The access address c at time 7 has a stack distance of 4 (note not the same as time distance!)\
since starting from time 1, four distinct addresses (d, a, b and c itself) have been accessed.\
In order to measure the LRU stack distance efficiently, we will need two supporting data structures:\
1. A symbol table that remembers the last access time for each address. The symbol table\
needs to support efficient search for the last access time based on an address, adding a new\
address, and updating the last access time for existing address. Check 
\f5\b\fs20 \cf4 SymbolTable.java\
\pard\pardeftab720\partightenfactor0

\f0\b0\fs24 \cf2 for detailed Big-O requirement and decide which data structure you should use.\
2. Storage of the last access times of all addresses we have processed. They need to be stored\
as a sorted sequence and must support efficient insertion, deletion, and counting how many\
values are there are no smaller than a specified value. Check 
\b \cf4 Sequence.java 
\b0 \cf2 for detailed\
Big-O requirement and decide which data structure you should use. 
\b Hint: 
\b0 any selfbalancing\
search tree will satisfy most of the requirements except for the counting. You will\
need to augment the normal self-balancing search tree to support this.\
\pard\pardeftab720\partightenfactor0

\b \cf5 Round 1 Classes Overview\
\pard\pardeftab720\partightenfactor0
\cf2 SymbolTable: 
\b0 Maintains the table for unique symbols (addresses) from a sequence of references. In\
the pair 
\f3 <SymbolType, RecordType> 
\f6\i SymbolType 
\f0\i0 represents different symbols and\
\pard\pardeftab720\partightenfactor0

\f6\i \cf2 RecordType 
\f0\i0 defines the record of each symbol (address), in our case the last access time. The\
class should support operations to count how many symbols are present in the table (
\f3 size
\f0 ), to\
check whether a symbol is present in the table (
\f3 hasSymbol
\f0 ), to find and return the record we\
store in table for a symbol (
\f3 getRecord
\f0 ), to set the record for a symbol (
\f3 putRecord
\f0 ), and to\
find and remove the entry of a symbol from the table (
\f3 removeSymbol
\f0 ). Class\
\pard\pardeftab720\partightenfactor0

\f4\fs16 \cf2 2 3\
\pard\pardeftab720\partightenfactor0

\fs24 \cf2 4\
\pard\pardeftab720\partightenfactor0

\f5\b\fs20 \cf4 SymbolTable.java 
\f0\b0\fs24 \cf2 defines the required interface while 
\f5\b\fs20 \cf4 MySymbolTable.java 
\f0\b0\fs24 \cf2 is the actual class\
you need to write code and implement SymbolTable interface.\
\pard\pardeftab720\partightenfactor0

\b \cf2 Sequence: 
\b0 Stores a collection of values as a sorted sequence with no duplicates. It should support\
operations such as inserting a new value in to the collection (
\f3 insert), 
\f0 removing a value from the\
collection (
\f3 remove), 
\f0 finding if a value is present in the collection 
\f3 (contains), 
\f0 finding\
how many values are present in the collection 
\f3 (size), 
\f0 and finding a string representation of all\
values in collection in ascending order (
\f3 toStringAscendingOrder)
\f0 . It also should support\
the method (
\f3 countNoSmallerThan
\f0 ) to count the values in the collection that are greater than\
or equals to a specific value. Class 
\f5\b\fs20 \cf4 Sequence.java 
\f0\b0\fs24 \cf2 defines the required interface while\
\pard\pardeftab720\partightenfactor0

\f5\b\fs20 \cf4 MySequence.java 
\f0\b0\fs24 \cf2 is the actual class you need to write code and implement Sequence interface.\
\pard\pardeftab720\partightenfactor0

\b \cf2 StackDistCollector: 
\b0 The class that calculates the (LRU) stack distance for any given sequence of\
accesses. Class 
\f5\b\fs20 \cf4 StackDist.java 
\f0\b0\fs24 \cf2 has been partially implemented and you will need to use both\
symbol table and sequence in this class. The only method you need to implement in this class is\
\pard\pardeftab720\partightenfactor0

\f5\b\fs20 \cf4 access
\f0\b0\fs24 \cf2 . This method takes in an address (represented as an integer in this project) and returns an\
integer value representing the LRU stack distance for that access. The inner class 
\f3 SymbolRecord
\f0 ,\
stores record we want to keep for every symbol (address) from the access sequence used in symbol\
table construction. Below is a scratch of steps to take to implement 
\f5\b\fs20 \cf4 access()
\f0\b0\fs24 \cf2 . For an access to 
\f5\b X\
\pard\pardeftab720\partightenfactor0

\f0\b0 \cf2 at time 
\f5\b T
\f0\b0 :\
1. Search the symbol table to find the last time 
\f5\b X 
\f0\b0 is accessed as 
\f5\b T'\

\f0\b0 2. Count and report how many distinct accesses are there in range 
\f5\b [T', T-1] 
\f0\b0 in the sequence\
3. Remove record for 
\f5\b T' 
\f0\b0 from the sequence storage and add a record for 
\f5\b T 
\f0\b0 in it\
4. Update symbol table for the new last access time for 
\f5\b X\

\f0\b0 Round 2\
For the second round, we will assume the future information is available (collected in round 1) and\
scan the given sequence of references in order to simulate an OPT cache. The cache is maintained\
as a priority queue with the following features:\
\pard\pardeftab720\partightenfactor0

\f1 \cf2 \uc0\u61589 
\f2  
\f0 The cache size is fixed\

\f1 \uc0\u61589 
\f2  
\f0 If the cache is full and a new address needs to be accessed, the address with the maximal\
forward distance (defined as below) will be replaced\
We should therefore implement cache as a fix-sized max-priority queue using the forward distance\
as the priority of each address. If there is a tie between forward distances, use the (unique) address\
to break the tie \'96 the larger address has a higher priority.\
\pard\pardeftab720\partightenfactor0

\b \cf2 Definition 2
\b0 : 
\b Forward distance 
\b0 of an address to 
\f5\b X 
\f0\b0 at time 
\f5\b T 
\f0\b0 is the number of distinct addresses\
referenced at time 
\f5\b T+1, T+2, . . ., T' 
\f0\b0 where 
\f5\b T' 
\f0\b0 is the next time that 
\f5\b X 
\f0\b0 is referenced. If 
\f5\b X\
\pard\pardeftab720\partightenfactor0

\f0\b0 \cf2 will not be accessed ever again, the forward distance is infinity.\
At time T, if X is accessed and the LRU stack distance of that access is L (from round 1), we should\
update the forward distance for all addresses in cache based on the following rules:\
\pard\pardeftab720\partightenfactor0

\f1 \cf2 \uc0\u61589 
\f2  
\f0 forward_distance(X) = L (same as LRU stack distance)\
\pard\pardeftab720\partightenfactor0

\f4 \cf2 5\
\pard\pardeftab720\partightenfactor0

\f1 \cf2 \uc0\u61589 
\f2  
\f0 for address Y \uc0\u8800  X\
\pard\pardeftab720\partightenfactor0

\f3 \cf2 o 
\f0 if forward_distance(Y) <= L, forward_distance(Y) = forward_distance(Y) -1\

\f3 o 
\f0 otherwise, forward_distance(Y) not changed\
\pard\pardeftab720\partightenfactor0

\b \cf2 Example:\
\pard\pardeftab720\partightenfactor0

\i\b0 \cf2 Access time: 
\f3\i0 0 1 2 3 4 5 6 7 8 9\

\f0\i Access sequence: 
\f3\i0 a b c a d b a d c d\

\f0\i LRU stack distance: 
\i0 3 4 4 3 3 \uc0\u8734  \u8734  2 \u8734  \u8734 \
(collected reversely in round1)\
Cache* a(3) b(4) c(4) c(4) d(3) b(\uc0\u8734 ) b(\u8734 ) b(\u8734 ) c(\u8734 ) c(\u8734 )\
of size 3: a(2) b(3) a(3) a(2) d(2) d(1) d(2) d(1) d(\uc0\u8734 )\
a(1) b(2) b(1) a(1) a(\uc0\u8734 ) a(\u8734 ) a(\u8734 ) a(\u8734 )\
Hit/Miss M M M H M H H H M H\
Replacement - - - - c - - - b** -\
* cache organized as a max priority queue, with the max item kept at top. X(N) represents an\
address with forward distance N.\
** both a and b have the same priority; break the tie using alphabetic order.\
\pard\pardeftab720\partightenfactor0

\b \cf5 Round 2 Classes Overview\
\pard\pardeftab720\partightenfactor0
\cf2 SymbolTable: 
\b0 Same as part 1.\

\b Priority Queue: 
\b0 The class maintains a max priority queue where priority of a parent node is higher\
than the priority of its children. It should support operations to count the number of items (
\f3 size
\f0 ),\
to return the max item (
\f3 peek
\f0 ), to remove the max item (
\f3 remove
\f0 ), to insert an item with its\
corresponding priority in to the queue (
\f3 insert
\f0 ), to check whether there exists an item with a\
priority (
\f3 contains
\f0 ), and to update the priority of an item (
\f3 updatePriority
\f0 ). Class\
\pard\pardeftab720\partightenfactor0

\f5\b\fs20 \cf4 PriorityQueue.java 
\f0\b0\fs24 \cf2 defines the required interface while 
\f5\b\fs20 \cf4 MyPriorityQueue.java 
\f0\b0\fs24 \cf2 is the actual\
class you need to write code which implements PriorityQueue interface.\
\pard\pardeftab720\partightenfactor0

\b \cf2 OPTCacheSimulator: 
\b0 The class that simulates a cache with OPT replacement policy. Class\
\pard\pardeftab720\partightenfactor0

\f5\b\fs20 \cf4 OPTCacheSimulator.java 
\f0\b0\fs24 \cf2 has been partially implemented and you will need to use both symbol\
table and priority queue in this class. The only method that you need to implement is 
\f5\b\fs20 \cf4 access
\f0\b0\fs24 \cf2 . This\
method takes in an address and the corresponding stack distance, simulates the cache processing and\
returns a boolean value representing whether the access is cache hit or miss. Below is a scratch of\
steps to take to implement 
\f5\b\fs20 \cf4 access()
\f0\b0\fs24 \cf2 . For an access to 
\f5\b X 
\f0\b0 at time 
\f5\b T 
\f0\b0 with stack distance 
\f5\b L
\f0\b0 :\
1. Search the symbol table to determine hit/miss and report that\
2. If it is a miss but the cache is not full, add 
\f5\b X 
\f0\b0 into cache. If it is a miss and the cache is full,\
remove address with the maximum forward distance, add 
\f5\b X
\f0\b0 .\
3. Update the symbol table\
4. Update the forward distances for addresses in cache as described above\
\
\pard\pardeftab720\partightenfactor0

\f4 \cf2 6\
\pard\pardeftab720\partightenfactor0

\f0\b\fs28 \cf5 Big-O\
\pard\pardeftab720\partightenfactor0

\b0\fs24 \cf6 Template given to you in the starter package contains instructions on the REQUIRED Big-O\
runtime for a subset of methods. For those methods, your implementation should not have a higher\
Big-O and you will be graded on this. \cf2 When you need to select a data structure that satisfies all big-\
O requirement for an interface.\
\pard\pardeftab720\partightenfactor0

\b\fs28 \cf5 Testing\
\pard\pardeftab720\partightenfactor0

\b0\fs24 \cf2 Test cases will not be provided for this project. However, feel free to create test cases by yourselves.\
In addition, the main methods provided along with the template classes contain useful code to test\
your code. You can use command like \'93
\f3\fs20 java 
\fs24 OPTCacheSimulator
\f0 \'94 to run the testing defined\
in main( ). You could also edit main( ) to perform additional testing. As always, a part of your grade\
will be based on automatic grading using test cases that are not provided to you. A set of input files\
is provided to you for testing purpose. Take a look at 
\f3 processSequence 
\f0 methods in\
\pard\pardeftab720\partightenfactor0

\f3 \cf2 OPTCacheSimulator 
\f0 and 
\f3 StackDistCollector, 
\f0 which can be used to perform a batch\
of tests. The method resets everything, opens a file, read in from the file, and process accesses one\
by one. More sequences will be available in the following couple of weeks.\
\pard\pardeftab720\partightenfactor0

\b\fs28 \cf5 References\
\pard\pardeftab720\partightenfactor0

\b0\fs22 \cf2 [1] 
\f7 Mattson, R. L., Gecsei, J., Slutz, D. R., et al. 
\i Evaluation Techniques for Storage Hierarchies
\i0 . IBM\
Systems Journal 9 (2): 78-117, 1970. Retrieved from:\
\pard\pardeftab720\sl259\slmult1\sa160\partightenfactor0

\f0 \cf2 http://inst.eecs.berkeley.edu/~cs266/sp10/readings/mattson70.pdf}